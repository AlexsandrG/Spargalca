Thread() - создаёт новый поток
Timer(iterval, function, args=None, kwargs=None) #- создаёт поток с указанием времени, через которое он должен запуститься
# iterval - значение секунд до запуска потока
# function - функция которую нужно вызвать
thd_1.active_count() #- количество потоков
thd_1.current_thread() #- количество потоков прямо сейчас
thd_1.threading.currentThread().name #- имя текущего потока
thd_1.main_thread() #- возвращает основной поток программы
thd_1.enumerate() #- возвращает список всех активных потоков
threading().main_thread().setName('New_name') #- изменяем имя главного потока
thd_1.setDaemon(True) #- преобразует поток в поток-daemon
threading.local() #- позволяет хранить данные в потоках и задавать нужные атрибуты и их значения
data = threading.local()#, далее
data.value = 111 #- создаём новый атрибут со значением.
print(data.value) #- вывод на экран
data.test = [123, 345] #- создаём новый атрибут со значением.
print(data.test)
                    #Семафоры
from threading import Thread, BoundedSemaphore

max_connections = 5 # как только 5 потоков завершатся, можно будет запустить следующие 5
pool = BoundedSemaphore(value=max_connections) # сколько пропускает потоков, по умолчанию 1
.realease() #- позволяет снять блокировку

                # Барьеры
Пример:
def test(barrier):
    print('Поток запущен')
    barrier.wait() # пока 5 потоков не поймают wait потоки дальше не пойдут
    print('Поток преодолел барьер')

bar = threading.Barrier(5) # создаём 5 барьеров
for i in range(5):
    threading.Thread(target=test, args=(bar,), name=f'thr-{i}').start() # создаём и запускаем поток с разными именами - thr-{i}




# defaultdict() - при обращении к несуществующему ключу, создаёт ключ и значение по умолчанию(которое передадим)
# и возвращает это значение
# defdict.default_factory =  int - передаём новое значение по умолчанию,принимает на вход объект функции

# Потоки-демоны — это потоки, которые выполняют задачи в фоновом режиме.

import threading

from threading import Thread # модуль для многопоточности


thread = Tread(target=fishing, kwargs=dict(name='Вася', worms=10))

# target - функция которую нужно запустить в многопоточность
# name - название потока
# args - аргументы, именованные аргументы(в виде кортежа)
# kwargs - именованные аргументы(в виде словаря)
# daemon - обычный поток или это поток daemon

thread.start() # запуск параллельного потока

fishing(name='Коля', worms=10)

thread.join() # ждёт основной поток
thread.acquire() # удерживаем поток
thread.release() # запускаем поток после паузы
flush=True # аргумент принта - что бы информация не копилась в буфере
_ = 3 ** (random.randint(5, 7) * 100_000) # - долгая операция

# Аргумент flush в функции print () в Python позволяет управлять выводом сообщений без задержек.
# Дело в том, что по умолчанию программа будет записывать данные вывода из print () сперва в буфер обмена,
# а уже потом выводить данные в консоль или в файл. По умолчанию аргумент flush установлен в значении False.
# Когда значение аргумента flush установлено в True, Python выводит сообщение, не дожидаясь буферизации вывода.

                Многопоточность в классах

class Fisher(Thread):   # наследуемся от класса Thread

    def __init__(self, name, worms, *args, **kwargs):
        super(Fisher, self).__init__(*args, **kwargs)
        self.name = name
        self.worms

    def run(self): # - переопределяем метод run
        pass

vasya = Fisher(name='Вася', worms=10)
kolya = Fisher(name='Коля', worms=10)

vasya.start()
kolya.start()

print('Что-то происохдит')

vasya.join()
kolya.join()

# Получаем три потока - основной поток программы и два потока с рыбаками

        # Блокировки потоков для доступа к общим данным
# состояние гонки - race conditions
# атомарные операции - выполняются единично и не могут быть прерваны во время их выполнения
lock = threading.Lock() # - блокировка, этот замок передаётся каждому потоку
lock = threading.RLock() # - блокировка, которая позволяет входить повторно - при вложенных блокировках
lock # - блокировка
acquire # - поток становится активным, остальные ждут, до release
release
# ...........................семафоры, условные переменые, кондишоны и другие
# Семафоры Semaphore - очень похожии на Lock, но позволяют выполнять критичный код нескольким потокам
# Барьер Barrier- позволяет нескольким потокам продолжить своё выполнение одновременно.
# Если в потоке есть barrier.wait()  то поток приостанавливается, пока все остальные потоки не вызовут barrier.wait()
# События Events- потоки могут ждать пока событие не будет установлено, а другой поток может устанавливать или сбрасывать это событие
# Условные переменные Condition  - позволяют потоку ждать, пока другой поток подготовит данные и сообщит об этом
# Таймер Timer _ похож на простой Thread, но начинает выполнение через N секунд


fishers = [Fisher(name=name, worms=100_000, fish_tank=globl_fish_tank, lock=lock) for name in humans]

for fisher in fishers:
    fisher.start()
for fisher in fishers:
    fisher.join()

# блокировка с помощью контекстного менеджера:

with self.lock:
    self.fish_tank[tank] +=1
# блокировка с помощью try except:

dedlock # - тупик, полная блокировка всего


            Очереди
Очередь FIFO:
queue.Queue() # реализует FIFO - "первым пришел - первым вышел"
Очередь LIFO:
 queue.LifoQueue() # используется порядок "последним пришел - первым вышел"

import queue

q = queue.Queue(maxsize=2) # очередь
# maxsize - максимальный размер очереди
q.qsize() # Размер очереди
q.empty() # проверяет пуста ли очередь
q.full() # проверяет очередь заполнена.
q.put(item, block=True, timeout=None) # размещает item в очереди
#  если block=True, а timeout=None то добавление элемента в очереди блокируется, пока не освободится свободный слот.
# (очередь не заполнена - not q.full())
#  если block=True, а timeout>0 то добавление элемента в очереди блокируется на timeout секунд.
                    #  По истечению времени выдаётся исключение queue.Full
#  если block=False и свободный слот доступен - not q.full(), то item добавляется в очередь
q.put_nowait(item) #  = q.put(item, False)
q.get(block=True, timeout=None) #  Получить item из очереди
#  если block=True, а timeout=None то получение элемента из очереди блокируется, пока item не станет доступным
#  (в очереди есть хотя бы 1 элемент - not q.empty()).
#  если block=True, а timeout>0 то получение элемента из очереди блокируется на timeout секунд.
                    #  По истечению времени выдаётся исключение queue.Empty
#  если block=False и item доступен - not q.empty(), то item возвращается
q.get_nowait() # = q.get(False).
q.join() # заблокировать очередь, пока все элементы в очереди не будут получены и обработаны.
q.task_done() # - ранее поставленная задача выполнена, т.е -
# Для вызова q.get(), метода Queue.task_done() сообщает очереди, что обработка задачи завершена.
# если очередь блокируется q.join() , то блокировка снимется, если все элементы будут обработаны q.task_done()
# вызывает исключение ValueError, если вызывается больше, чем было элементов в очереди.

            Многопроцессное программирование
from multiprocessing import Process, Pipe, Queue
# if __name__ == '__main__': - обязательно
Process вместо Thread
Process(name=name_func, conn=Pipe())
conn=Pipe() #- для сообщения, труба содержит 1 объект
first = Pipe()
self.conn.send(what) # what- что передать
self.conn.close() # - закрыть нужно
conv.recv() # - передаёт объект, который передали с другой стороны
